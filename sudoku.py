# -*- coding: utf-8 -*-
"""sudoku.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16V9j2bOC1GH-ZpkKv1R_ho4jzCw9utFe

1/ Импортируем функцию product
https://docs.python.org/3/library/itertools.html#itertools.product

Она эквивалентна вложенным циклам for в выражении-генераторе. Например, product(A, B) возвращает то же самое, что и ((x,y) for x in A for y in B).

2/ Импортируем cv2 — основной модуль библиотеки OpenCV для программирования на Python. Он предоставляет функции для обработки и анализа изображений, от базовых операций до сложных алгоритмов распознавания и анализа объектов.

3/ numpy и pandas - используются для анализа данных, работы с матрицами, дата фреймами и т д

4/ Pulp (PuLP) — библиотека для моделирования и решения задач оптимизации на языке Python. Она поддерживает линейное программирование (LP), смешанное целочисленное программирование (MIP) и программирование с ограничениями.
"""

!pip install Pulp

# Commented out IPython magic to ensure Python compatibility.
from itertools import product # декартово произведение


import cv2
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from pulp import *

# %matplotlib inline
# графики будут внутри ячеек с кодом

def sort_corners(corners):
    # 1. Найти центроид
    centroid_x = np.mean(corners[:, 0, 0])
    centroid_y = np.mean(corners[:, 0, 1])

    # 2. Функция для вычисления угла вектора
    def angle(point):
        dx = point[0, 0] - centroid_x
        dy = point[0, 1] - centroid_y
        return np.arctan2(dy, dx)  # Угол в радианах

    # 3. Сортируем углы по углу относительно центроида
    sorted_corners = sorted(corners, key=angle)

    # 4. (Необязательно) Перемещаем так, чтобы "верхний левый" был первым
    #   Можно определить критерий, что является "верхним левым"
    #   Например, угол, у которого сумма координат минимальна

    return np.array(sorted_corners)

# Открываем изображение с судоку
img = cv2.imread('/Screenshot from 2025-05-27 06-28-10.png')

# Находим контуры на изображении
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# переводим изображение в серый цвет
blurry = cv2.GaussianBlur(gray, (5, 5), 1) # сглаживаем края, чтобы повысить точность обнаружения результатов
thresh = cv2.adaptiveThreshold(blurry, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV,57,5)
# порог к размытому изображению, пиксели, превышающие порог будут ноль, остальные в 255
# размер окреастности, использумой для вычисления порога устанавливаем 57, константа, которая вычитается из среднего значения - 5
cnts,_ = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE) # находим контуры на бинаризованном изображении
cnts = sorted(cnts, key=cv2.contourArea, reverse=True) # сортируем контуры по площади в порядке убывания (доска судоку по идее самый большой контур на изображении)

# Для поиска сетки судоку находим наибольший квадрат на изображении
location = None
for cnt in cnts: # перебираем контуры
    approx = cv2.approxPolyDP(cnt, 15, True)
    if len(approx) == 4: # проверяем, что контур четырехугольник
        # Сортировка углов по часовой стрелке
        rect = np.zeros((4, 2), dtype = "float32") # массив для хранения координат углов четырехугольника
        cutt = approx[:,0] # берем координаты из approx
        print(cutt)
# 0,0 тут
#   ВЛ: x + y            ВП: x + dx + y
#   НЛ: x + (y + dy)     НП: x + dx + (y + dy)
        diag_1 = cutt.sum(axis = 1)        # сумма координат для каждого угла
        rect[0] = cutt[np.argmin(diag_1)] # верхний левый угол - наименьшая сумма координат
        rect[2] = cutt[np.argmax(diag_1)] # нижний правый - наибольшая сумма координат

        diag_2 = np.diff(cutt, axis = 1) # разность координат
        rect[1] = cutt[np.argmin(diag_2)] # нижний левый- меньшая разность к-т так как она равна +dx
        rect[3] = cutt[np.argmax(diag_2)] # верхний правый угол - наибольшая разность к-т так как она равна -dy

        location = rect # отсортированные координаты углов сохраняем
        print(location)
        # ВЛ НЛ ВП НП
        # 0  1  2   3
        break

# Создаём квадрат 900х900 для отображения судоку
height = 900
width = 900
pts1 = np.float32([location[0], location[1], location[3], location[2]])
pts2 = np.float32([[0, 0], [width, 0], [0, height], [width, height]])

# попытки улучшить распознавание
#img = cv2.convertScaleAbs(img, alpha = 1, beta = 10)
#gray_image = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
#img = cv2.equalizeHist(gray_image)

# Вписываем судоку в наш квадрат
matrix = cv2.getPerspectiveTransform(pts1, pts2)
board = cv2.warpPerspective(img, matrix, (width, height))

# Отображение результата
fig, ax = plt.subplots(1, 4, figsize=(15,15))
for i, j in zip(range(len(ax)), [img, gray,  thresh, board]):
   ax[i].imshow(j)



pip install easyocr

# Загружаем модель OCR (оптическое распознавание символов)
import easyocr
reader = easyocr.Reader(['en'])

# Создаём датафрейм и список для записи распознанных результатов
df = pd.DataFrame(index=range(1, 10), columns=range(1, 10))
sudoku_map = []

# Создаём оси для отрисовки разделённых изображений
fig, ax = plt.subplots(9, 9, figsize=(8,8))

# Разделяем наш судоку на 9 строк и 9 столбцов и распознаём каждое значение
split = np.split(board, 9, axis=1)

for col,j  in enumerate(split):
    digs = np.split(j, 9) # тут разделяем горизонтальные блоки на 9 ячеек

    for row,d in enumerate(digs):
        # Обрежем по 10 пикселей с каждой стороны ячейки, чтобы убрать рамки
        d = d[10:90,10:90]
        #cv2.copyMakeBorder(d,10,10,10,10,cv2.BORDER_CONSTANT) # это рамка вокруг изображения
        ax[row][col].imshow(d) #отображаем клетки судоку
        ax[row][col].axis('off') # убираем оси, чтобы не мешали

        # Распознаём число в ячейке и записываем его в датафрейм и список с координатами
        text = reader.readtext(d, allowlist='0123456789', detail=0)
        # распознавание цифр из списка 0123456789 без дополнительной информации
        if len(text) > 0: # проверяем был ли распознан текст
            df.iloc[row, col] = text[0] # если да - записываем его в датафрейм
            sudoku_map.append([text[0], str(row+1), str(col+1)])

df.fillna('', inplace=True) # заполняем все пустые ячейки пустой строкой
df # выводим дата фрейм

# Создаём списки для перебора в Pulp
nums = [*map(str, [*range(1,10)])] # список чисел от 1 до 9 со строковым типом
rows = nums
cols = nums
vals = nums # цифра в ячейке

# Создаём Pulp словарь с переменными возможных ответов
choices = LpVariable.dicts("Choice", (vals, rows, cols), 0, 1, LpInteger)

# Создаём задачу для Pulp
prob = LpProblem("Судоку", LpMaximize)
prob += 0, "Целевая функция" # Задаётся нулём, так как нас интересует только подбор значения согласно ограничениям

# Задаём ограничениями условие, что каждое число в каждой строке и каждом столбце должно повторяться не более 1 раза
for r, c in product(rows, cols): # перебор комбинаций r, c
    prob += lpSum([choices[v][r][c] for v in vals]) == 1, ""
# с помощью переменной линейного программирования (которая равна 1, если цифра v находится в строке r и столбце c, и 0 в противном случае) перебираем возможные значения
# в каждой ячейке только одна цифра

# в каждой строке r цифра v должна встречаться ровно один раз
for v, r in product(vals, rows):
    prob += lpSum([choices[v][r][c] for c in cols]) == 1, ""

#в каждом столбце c цифра v должна встречаться ровно один раз
for v, c in product(vals, cols):
    prob += lpSum([choices[v][r][c] for r in rows]) == 1, ""

# Задаём аналогичные ограничения для малых квадратов 3х3
# в каждом квадрате 3x3 цифра v должна встречаться ровно один раз
grid = (range(3), range(3)) # координаты квадратов 3х3
subs = [[(rows[3 * i + k],cols[3 * j + l]) for k,l in product(*grid)] for i,j in product(*grid)] # кортеж из квадратов
for v,s in product(vals, subs):
    prob += lpSum([choices[v][r][c] for (r, c) in s]) == 1, ""

# Добавляем в задачу известные значения, распознанные OCR
for num in sudoku_map:
    prob += choices[num[0]][num[1]][num[2]] == 1, ""

# Решаем задачу
prob.solve()

# Отрисовка конечного результата
fig, ax = plt.subplots(1,2, figsize=(15,15))
for a in ax:
    a.axis('off')
    a.imshow(board)

ax[0].set_title('Задача', fontsize=25)
ax[1].set_title('Решение', fontsize=25)

# Пишем решение поверх изображения
y = 50
for r in rows:
    x = 50
    for c,v in product(cols, vals):
        if choices[v][r][c].value() == 1:
            if [v,r,c] not in sudoku_map: # Пишем только подобранные значения
                ax[1].text(x,y,v, ha='center', va='center', fontsize=25, color='tab:green')
            x += 100
    y += 100

